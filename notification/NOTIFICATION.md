
https://practicum.yandex.ru/learn/middle-python-plus-async/courses/b71219f0-2c3d-422e-8253-b54c1b3ccda2/sprints/222058/topics/b14c5d2a-18c7-4132-8045-492d92a5262c/lessons/993eca31-4ca8-4909-84af-f5fd0e86aa33/
# Задание

(Спроектируйте ваш сервис уведомлений и отправьте наставнику на проверку.
Повторим, какие возможные компоненты есть в системе нотификации:
База, в которой хранятся уведомления notification_id и content_id.
API для приёма событий по созданию уведомлений (а может стоит через него управлять и уведомлениями в базе?):
API процесс;
база, в которой хранится история отправки уведомлений (а может и не здесь).
Процесс, который отправляет уведомление (воркер):
База, в которой хранится история отправки уведомлений (а может и не здесь).
Генератор автоматических событий:
шедулер;
cron;
база, в которой хранится периодичность уведомлений (а лучше бы это была одна база с п. 1).
Админ-панель.)


1) Шаблоны уведомлений можно хранить в отдельной таблице постгреса (рядом с данными авторизации)
2) База в которой хранятся уведомления
   * можно развернуть монгу, при переподнятии контейнера будут храниться данные о последних изменениях
3) Апишка для приема событий по созданию уведомлений
   * автоамтические рассылки (при создании  определенных эвентов (лайки на комменте и возмоно еще что-то), регистрации, авторизации и т.д.)
   * периодические рассылки (при добавлении новых фильмов, сериалов и т.д.)
   * ручные рассылки админом (уведомления, акции и т.д.)
3) ETL обработчик событий (реббит + селери)
4) Админка (видимо на джанге)



Подумать над возможными воркерами внутри имеющихся сервисов (я вижу наобность в реализации следующих рассылках, возможно нужно что-то еще)

1) OAUTH
   * регистрация
   * авторизация

3) UGC
   * эвенты лайков фильмов

4) ADMIN
   * добавление нового фильма
   * ручка рассылки (как пример скидка на праздник, скидка при покупке подписки, истечение срока подписки, поздравление с ДР....)
   * ?????????? ручка кастомных рассылок 



# Задание 1)

(Задание 1
В уроке рассматривались два варианта подготовки данных для отправки уведомлений: собирать данные до воркера и отправлять их в него или собирать данные в самом воркере.
Лучше всего использовать третий вариант — гибридный.
Спроектируйте и распишите гибридный формат работы API, воркера, генератора автоматических уведомлений и админ-панели для трёх сценариев:
Любая часть сайта просит отправить мгновенное уведомление.
Генератор автоматических событий сгенерировал событие или события на большую группу пользователей.
Админ-панель, в которой менеджеры вручную создали рассылку уведомлений пользователям.)

## не особо понимаю как именно и что тут нужно расписать и нарисовать




# Задание 2)

(
Спроектируйте сервис уведомлений. Используйте готовые компоненты и подходы из урока, инструменты из прошлого модуля (Сервис UGC, урок «Выявление требований: от идеи до реализации»), а главное — свои идеи и решения конкретных сценариев.
Требования к итоговой архитектуре:
Для простоты можно рассылать только email-письма, но система должна иметь возможность расширения на другие типы уведомлений: смс, push и другие варианты.
Мгновенные уведомления должны отправляться с максимальной задержкой в несколько минут.
В случае падения любого компонента ничего не должно потеряться и любое уведомление должно быть получено клиентом.
В случае простоя генератора автоматических уведомлений (или аналогичного компонента) после его запуска не должны дублироваться старые и новые события.
Должна быть возможность настройки уведомлений пользователем, в том числе отключение уведомлений.
Должна быть единая система шаблонизации email-писем как для автоматических уведомлений, так и для рассылок, созданных менеджером.
У системы должна быть возможность масштабироваться.)

пожно перерисовать вот это под нашу задачу 
![img.png](img.png)

поднимаем отдельно контейнеры селери и ребит

Добавляем коннектор селери в каждый сервис который будет генерить задачи 

записываем все рассылки в ETL монго 

через ETL ребит читаем из ETL монго все что нам шлет селери в него и делаем рассылку (мне кажется можно сделать в 
монге поле статуса отправки и если от ребита не пришло что рассылка произведена (*если так можно*) то производим рассылку повторно)




# Задание
Реализуйте в своём сервисе модуль, отвечающий за генерацию и отправку персонализированных писем.
Реализуйте модуль для работы с Websocket.


# Задача
Отдел маркетинга запускает новую рекламную кампанию. Нужно привлечь внимание пользователей к новым фичам онлайн-кинотеатра и увеличить конверсию в покупку новых фильмов. Для этого каждому пользователю необходимо отправить письмо с информацией и данными.
Технически требуется загрузить все письма в очередь на рассылку и полностью обработать её.
Пропишем чек-лист, чтобы ничего не забыть:
Персонифицировать каждое письмо. Для этого создайте шаблон письма с подставляемыми данными, который будет обогащаться данными пользователя перед отправкой.
При обогащении данными предусмотреть возможное влияние пиковой нагрузки на распределённую систему. Одновременная обработка большого количества данных не должна приводить, например, к отказу подсистемы данных о пользователях при большом количестве одновременных запросов за данными.
Подсказка: регулировать нагрузку можно количеством одновременных запущенных консьюмеров. Также можно управлять скоростью работы каждого отдельного консьюмера при помощи таймаутов (sleep).
Ещё подсказка: снизить аффект на распределённую систему можно выделением специализированных slave-нод с данными только под чтение операции. Master-сервер при этом продолжит обслуживать клиентов в штатном режиме. Этот способ поможет распределить нагрузку, однако он дороже, сложнее в реализации и имеет свои особенности. Например, отставание slave-ноды от master: так вы рискуете отправить устаревшие данные.
Предусмотреть failover-стратегию. Одна из подсистем всё-таки отказала. Что будет происходить с запущенной рассылкой? Как восстановить упавшую подсистему? Как снизить нагрузку на подсистему сразу после её восстановления?
Подсказка: при отказе одной из подсистем нужно иметь возможность мгновенно отключить любые запросы на неё. Это можно сделать, например, остановив все консьюмеры подготовки или отправки писем. После восстановления нужно отрегулировать входящую нагрузку на подсистему, чтобы не получилось повторного отказа. Опять же это можно сделать регулировкой количества одновременно запущенных консьюмеров и скоростью работы каждого консьюмера.
При загрузке большого количества писем в очередь предусмотреть возможность снижения пикового RPS на запись. Это нужно для снижения аффекта на другие очереди этого сервера.
Подсказка: в процессе считывания данных из БД и публикации сообщений в очередь RabbitMQ на обработку, предусмотрите возможность искусственного занижения скорости публикации. Это можно сделать, встроив в цикл операцию sleep. Если пиковый RPS на запись начнёт аффектить другие очереди на том же сервере, нужно понизить скорость отправки сообщений в шину, увеличив параметр sleep. Обратите внимание, что связь между API и очередью может быть медленной и буферизировать данные при необходимости.
Предусмотреть в консьюмерах обработку ситуации с временными ошибками внешних сервисов. Они не должны приводить к потере конкретного сообщения.
Подсказка: иногда при потоковой обработке большого объёма данных могут «выстреливать» временные ошибки, например, флап базы данных или сети. В таких ситуациях обычно консьюмеры начинают ределиверить — пытаться снова и снова обработать сообщение и тем самым останавливают обработку всей очереди. Для таких ситуаций научите консьюмеров деградировать — отправлять проблемное сообщение во временную очередь, чтобы через некоторое время вернуться к его обработке. В RabbitMQ это делается через Dead Letter Queue.
Убедиться, что обработка каждого сообщения идемпотентна. То есть повторная обработка того же самого сообщения не приводит к повторной отправке письма.